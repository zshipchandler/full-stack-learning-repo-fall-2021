{"ast":null,"code":"/*! firebase-admin v10.0.0 */\n\"use strict\";\n/*!\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseAuth = exports.createFirebaseTokenGenerator = void 0;\n\nvar error_1 = require(\"../utils/error\");\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar validator = require(\"../utils/validator\");\n\nvar auth_api_request_1 = require(\"./auth-api-request\");\n\nvar token_generator_1 = require(\"./token-generator\");\n\nvar token_verifier_1 = require(\"./token-verifier\");\n\nvar auth_config_1 = require(\"./auth-config\");\n\nvar user_record_1 = require(\"./user-record\");\n\nvar identifier_1 = require(\"./identifier\");\n\nvar crypto_signer_1 = require(\"../utils/crypto-signer\");\n/**\n * @internal\n */\n\n\nfunction createFirebaseTokenGenerator(app, tenantId) {\n  try {\n    var signer = auth_api_request_1.useEmulator() ? new token_generator_1.EmulatedSigner() : crypto_signer_1.cryptoSignerFromApp(app);\n    return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);\n  } catch (err) {\n    throw token_generator_1.handleCryptoSignerError(err);\n  }\n}\n\nexports.createFirebaseTokenGenerator = createFirebaseTokenGenerator;\n/**\n * Common parent interface for both `Auth` and `TenantAwareAuth` APIs.\n */\n\nvar BaseAuth =\n/** @class */\nfunction () {\n  /**\n   * The BaseAuth class constructor.\n   *\n   * @param app - The FirebaseApp to associate with this Auth instance.\n   * @param authRequestHandler - The RPC request handler for this instance.\n   * @param tokenGenerator - Optional token generator. If not specified, a\n   *     (non-tenant-aware) instance will be created. Use this paramter to\n   *     specify a tenant-aware tokenGenerator.\n   * @constructor\n   * @internal\n   */\n  function BaseAuth(app,\n  /** @internal */\n  authRequestHandler, tokenGenerator) {\n    this.authRequestHandler = authRequestHandler;\n\n    if (tokenGenerator) {\n      this.tokenGenerator = tokenGenerator;\n    } else {\n      this.tokenGenerator = createFirebaseTokenGenerator(app);\n    }\n\n    this.sessionCookieVerifier = token_verifier_1.createSessionCookieVerifier(app);\n    this.idTokenVerifier = token_verifier_1.createIdTokenVerifier(app);\n  }\n  /**\n   * Creates a new Firebase custom token (JWT) that can be sent back to a client\n   * device to use to sign in with the client SDKs' `signInWithCustomToken()`\n   * methods. (Tenant-aware instances will also embed the tenant ID in the\n   * token.)\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/create-custom-tokens | Create Custom Tokens}\n   * for code samples and detailed documentation.\n   *\n   * @param uid - The `uid` to use as the custom token's subject.\n   * @param developerClaims - Optional additional claims to include\n   *   in the custom token's payload.\n   *\n   * @returns A promise fulfilled with a custom token for the\n   *   provided `uid` and payload.\n   */\n\n\n  BaseAuth.prototype.createCustomToken = function (uid, developerClaims) {\n    return this.tokenGenerator.createCustomToken(uid, developerClaims);\n  };\n  /**\n   * Verifies a Firebase ID token (JWT). If the token is valid, the promise is\n   * fulfilled with the token's decoded claims; otherwise, the promise is\n   * rejected.\n   *\n   * If `checkRevoked` is set to true, first verifies whether the corresponding\n   * user is disabled. If yes, an `auth/user-disabled` error is thrown. If no,\n   * verifies if the session corresponding to the ID token was revoked. If the\n   * corresponding user's session was invalidated, an `auth/id-token-revoked`\n   * error is thrown. If not specified the check is not applied.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/verify-id-tokens | Verify ID Tokens}\n   * for code samples and detailed documentation.\n   *\n   * @param idToken - The ID token to verify.\n   * @param checkRevoked - Whether to check if the ID token was revoked.\n   *   This requires an extra request to the Firebase Auth backend to check\n   *   the `tokensValidAfterTime` time for the corresponding user.\n   *   When not specified, this additional check is not applied.\n   *\n   * @returns A promise fulfilled with the\n   *   token's decoded claims if the ID token is valid; otherwise, a rejected\n   *   promise.\n   */\n\n\n  BaseAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    var isEmulator = auth_api_request_1.useEmulator();\n    return this.idTokenVerifier.verifyJWT(idToken, isEmulator).then(function (decodedIdToken) {\n      // Whether to check if the token was revoked.\n      if (checkRevoked || isEmulator) {\n        return _this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n      }\n\n      return decodedIdToken;\n    });\n  };\n  /**\n   * Gets the user data for the user corresponding to a given `uid`.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n   * for code samples and detailed documentation.\n   *\n   * @param uid - The `uid` corresponding to the user whose data to fetch.\n   *\n   * @returns A promise fulfilled with the user\n   *   data corresponding to the provided `uid`.\n   */\n\n\n  BaseAuth.prototype.getUser = function (uid) {\n    return this.authRequestHandler.getAccountInfoByUid(uid).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Gets the user data for the user corresponding to a given email.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n   * for code samples and detailed documentation.\n   *\n   * @param email - The email corresponding to the user whose data to\n   *   fetch.\n   *\n   * @returns A promise fulfilled with the user\n   *   data corresponding to the provided email.\n   */\n\n\n  BaseAuth.prototype.getUserByEmail = function (email) {\n    return this.authRequestHandler.getAccountInfoByEmail(email).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Gets the user data for the user corresponding to a given phone number. The\n   * phone number has to conform to the E.164 specification.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n   * for code samples and detailed documentation.\n   *\n   * @param phoneNumber - The phone number corresponding to the user whose\n   *   data to fetch.\n   *\n   * @returns A promise fulfilled with the user\n   *   data corresponding to the provided phone number.\n   */\n\n\n  BaseAuth.prototype.getUserByPhoneNumber = function (phoneNumber) {\n    return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Gets the user data for the user corresponding to a given provider id.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n   * for code samples and detailed documentation.\n   *\n   * @param providerId - The provider ID, for example, \"google.com\" for the\n   *   Google provider.\n   * @param uid - The user identifier for the given provider.\n   *\n   * @returns A promise fulfilled with the user data corresponding to the\n   *   given provider id.\n   */\n\n\n  BaseAuth.prototype.getUserByProviderUid = function (providerId, uid) {\n    // Although we don't really advertise it, we want to also handle\n    // non-federated idps with this call. So if we detect one of them, we'll\n    // reroute this request appropriately.\n    if (providerId === 'phone') {\n      return this.getUserByPhoneNumber(uid);\n    } else if (providerId === 'email') {\n      return this.getUserByEmail(uid);\n    }\n\n    return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Gets the user data corresponding to the specified identifiers.\n   *\n   * There are no ordering guarantees; in particular, the nth entry in the result list is not\n   * guaranteed to correspond to the nth entry in the input parameters list.\n   *\n   * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,\n   * this method throws a FirebaseAuthError.\n   *\n   * @param identifiers - The identifiers used to indicate which user records should be returned.\n   *     Must not have more than 100 entries.\n   * @returns A promise that resolves to the corresponding user records.\n   * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100\n   *     identifiers are specified.\n   */\n\n\n  BaseAuth.prototype.getUsers = function (identifiers) {\n    if (!validator.isArray(identifiers)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');\n    }\n\n    return this.authRequestHandler.getAccountInfoByIdentifiers(identifiers).then(function (response) {\n      /**\n       * Checks if the specified identifier is within the list of\n       * UserRecords.\n       */\n      var isUserFound = function (id, userRecords) {\n        return !!userRecords.find(function (userRecord) {\n          if (identifier_1.isUidIdentifier(id)) {\n            return id.uid === userRecord.uid;\n          } else if (identifier_1.isEmailIdentifier(id)) {\n            return id.email === userRecord.email;\n          } else if (identifier_1.isPhoneIdentifier(id)) {\n            return id.phoneNumber === userRecord.phoneNumber;\n          } else if (identifier_1.isProviderIdentifier(id)) {\n            var matchingUserInfo = userRecord.providerData.find(function (userInfo) {\n              return id.providerId === userInfo.providerId;\n            });\n            return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;\n          } else {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');\n          }\n        });\n      };\n\n      var users = response.users ? response.users.map(function (user) {\n        return new user_record_1.UserRecord(user);\n      }) : [];\n      var notFound = identifiers.filter(function (id) {\n        return !isUserFound(id, users);\n      });\n      return {\n        users: users,\n        notFound: notFound\n      };\n    });\n  };\n  /**\n   * Retrieves a list of users (single batch only) with a size of `maxResults`\n   * starting from the offset as specified by `pageToken`. This is used to\n   * retrieve all the users of a specified project in batches.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#list_all_users | List all users}\n   * for code samples and detailed documentation.\n   *\n   * @param maxResults - The page size, 1000 if undefined. This is also\n   *   the maximum allowed limit.\n   * @param pageToken - The next page token. If not specified, returns\n   *   users starting without any offset.\n   * @returns A promise that resolves with\n   *   the current batch of downloaded users and the next page token.\n   */\n\n\n  BaseAuth.prototype.listUsers = function (maxResults, pageToken) {\n    return this.authRequestHandler.downloadAccount(maxResults, pageToken).then(function (response) {\n      // List of users to return.\n      var users = []; // Convert each user response to a UserRecord.\n\n      response.users.forEach(function (userResponse) {\n        users.push(new user_record_1.UserRecord(userResponse));\n      }); // Return list of user records and the next page token if available.\n\n      var result = {\n        users: users,\n        pageToken: response.nextPageToken\n      }; // Delete result.pageToken if undefined.\n\n      if (typeof result.pageToken === 'undefined') {\n        delete result.pageToken;\n      }\n\n      return result;\n    });\n  };\n  /**\n   * Creates a new user.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#create_a_user | Create a user}\n   * for code samples and detailed documentation.\n   *\n   * @param properties - The properties to set on the\n   *   new user record to be created.\n   *\n   * @returns A promise fulfilled with the user\n   *   data corresponding to the newly created user.\n   */\n\n\n  BaseAuth.prototype.createUser = function (properties) {\n    var _this = this;\n\n    return this.authRequestHandler.createNewAccount(properties).then(function (uid) {\n      // Return the corresponding user record.\n      return _this.getUser(uid);\n    }).catch(function (error) {\n      if (error.code === 'auth/user-not-found') {\n        // Something must have happened after creating the user and then retrieving it.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n      }\n\n      throw error;\n    });\n  };\n  /**\n   * Deletes an existing user.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#delete_a_user | Delete a user}\n   * for code samples and detailed documentation.\n   *\n   * @param uid - The `uid` corresponding to the user to delete.\n   *\n   * @returns An empty promise fulfilled once the user has been\n   *   deleted.\n   */\n\n\n  BaseAuth.prototype.deleteUser = function (uid) {\n    return this.authRequestHandler.deleteAccount(uid).then(function () {// Return nothing on success.\n    });\n  };\n  /**\n   * Deletes the users specified by the given uids.\n   *\n   * Deleting a non-existing user won't generate an error (i.e. this method\n   * is idempotent.) Non-existing users are considered to be successfully\n   * deleted, and are therefore counted in the\n   * `DeleteUsersResult.successCount` value.\n   *\n   * Only a maximum of 1000 identifiers may be supplied. If more than 1000\n   * identifiers are supplied, this method throws a FirebaseAuthError.\n   *\n   * This API is currently rate limited at the server to 1 QPS. If you exceed\n   * this, you may get a quota exceeded error. Therefore, if you want to\n   * delete more than 1000 users, you may need to add a delay to ensure you\n   * don't go over this limit.\n   *\n   * @param uids - The `uids` corresponding to the users to delete.\n   *\n   * @returns A Promise that resolves to the total number of successful/failed\n   *     deletions, as well as the array of errors that corresponds to the\n   *     failed deletions.\n   */\n\n\n  BaseAuth.prototype.deleteUsers = function (uids) {\n    if (!validator.isArray(uids)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');\n    }\n\n    return this.authRequestHandler.deleteAccounts(uids,\n    /*force=*/\n    true).then(function (batchDeleteAccountsResponse) {\n      var result = {\n        failureCount: 0,\n        successCount: uids.length,\n        errors: []\n      };\n\n      if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {\n        return result;\n      }\n\n      result.failureCount = batchDeleteAccountsResponse.errors.length;\n      result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;\n      result.errors = batchDeleteAccountsResponse.errors.map(function (batchDeleteErrorInfo) {\n        if (batchDeleteErrorInfo.index === undefined) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');\n        }\n\n        var errMsgToError = function (msg) {\n          // We unconditionally set force=true, so the 'NOT_DISABLED' error\n          // should not be possible.\n          var code = msg && msg.startsWith('NOT_DISABLED') ? error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;\n          return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);\n        };\n\n        return {\n          index: batchDeleteErrorInfo.index,\n          error: errMsgToError(batchDeleteErrorInfo.message)\n        };\n      });\n      return result;\n    });\n  };\n  /**\n   * Updates an existing user.\n   *\n   * See {@link https://firebsae.google.com/docs/auth/admin/manage-users#update_a_user | Update a user}\n   * for code samples and detailed documentation.\n   *\n   * @param uid - The `uid` corresponding to the user to update.\n   * @param properties - The properties to update on\n   *   the provided user.\n   *\n   * @returns A promise fulfilled with the\n   *   updated user data.\n   */\n\n\n  BaseAuth.prototype.updateUser = function (uid, properties) {\n    var _this = this; // Although we don't really advertise it, we want to also handle linking of\n    // non-federated idps with this call. So if we detect one of them, we'll\n    // adjust the properties parameter appropriately. This *does* imply that a\n    // conflict could arise, e.g. if the user provides a phoneNumber property,\n    // but also provides a providerToLink with a 'phone' provider id. In that\n    // case, we'll throw an error.\n\n\n    properties = deep_copy_1.deepCopy(properties);\n\n    if (properties === null || properties === void 0 ? void 0 : properties.providerToLink) {\n      if (properties.providerToLink.providerId === 'email') {\n        if (typeof properties.email !== 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To \" + 'link to the email/password provider, only specify the UpdateRequest.email field.');\n        }\n\n        properties.email = properties.providerToLink.uid;\n        delete properties.providerToLink;\n      } else if (properties.providerToLink.providerId === 'phone') {\n        if (typeof properties.phoneNumber !== 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To \" + 'link to a phone provider, only specify the UpdateRequest.phoneNumber field.');\n        }\n\n        properties.phoneNumber = properties.providerToLink.uid;\n        delete properties.providerToLink;\n      }\n    }\n\n    if (properties === null || properties === void 0 ? void 0 : properties.providersToUnlink) {\n      if (properties.providersToUnlink.indexOf('phone') !== -1) {\n        // If we've been told to unlink the phone provider both via setting\n        // phoneNumber to null *and* by setting providersToUnlink to include\n        // 'phone', then we'll reject that. Though it might also be reasonable\n        // to relax this restriction and just unlink it.\n        if (properties.phoneNumber === null) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To \" + 'unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.');\n        }\n      }\n    }\n\n    return this.authRequestHandler.updateExistingAccount(uid, properties).then(function (existingUid) {\n      // Return the corresponding user record.\n      return _this.getUser(existingUid);\n    });\n  };\n  /**\n   * Sets additional developer claims on an existing user identified by the\n   * provided `uid`, typically used to define user roles and levels of\n   * access. These claims should propagate to all devices where the user is\n   * already signed in (after token expiration or when token refresh is forced)\n   * and the next time the user signs in. If a reserved OIDC claim name\n   * is used (sub, iat, iss, etc), an error is thrown. They are set on the\n   * authenticated user's ID token JWT.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/custom-claims |\n   * Defining user roles and access levels}\n   * for code samples and detailed documentation.\n   *\n   * @param uid - The `uid` of the user to edit.\n   * @param customUserClaims - The developer claims to set. If null is\n   *   passed, existing custom claims are deleted. Passing a custom claims payload\n   *   larger than 1000 bytes will throw an error. Custom claims are added to the\n   *   user's ID token which is transmitted on every authenticated request.\n   *   For profile non-access related user attributes, use database or other\n   *   separate storage systems.\n   * @returns A promise that resolves when the operation completes\n   *   successfully.\n   */\n\n\n  BaseAuth.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n    return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims).then(function () {// Return nothing on success.\n    });\n  };\n  /**\n   * Revokes all refresh tokens for an existing user.\n   *\n   * This API will update the user's {@link UserRecord.tokensValidAfterTime} to\n   * the current UTC. It is important that the server on which this is called has\n   * its clock set correctly and synchronized.\n   *\n   * While this will revoke all sessions for a specified user and disable any\n   * new ID tokens for existing sessions from getting minted, existing ID tokens\n   * may remain active until their natural expiration (one hour). To verify that\n   * ID tokens are revoked, use {@link BaseAuth.verifyIdToken}\n   * where `checkRevoked` is set to true.\n   *\n   * @param uid - The `uid` corresponding to the user whose refresh tokens\n   *   are to be revoked.\n   *\n   * @returns An empty promise fulfilled once the user's refresh\n   *   tokens have been revoked.\n   */\n\n\n  BaseAuth.prototype.revokeRefreshTokens = function (uid) {\n    return this.authRequestHandler.revokeRefreshTokens(uid).then(function () {// Return nothing on success.\n    });\n  };\n  /**\n   * Imports the provided list of users into Firebase Auth.\n   * A maximum of 1000 users are allowed to be imported one at a time.\n   * When importing users with passwords,\n   * {@link UserImportOptions} are required to be\n   * specified.\n   * This operation is optimized for bulk imports and will ignore checks on `uid`,\n   * `email` and other identifier uniqueness which could result in duplications.\n   *\n   * @param users - The list of user records to import to Firebase Auth.\n   * @param options - The user import options, required when the users provided include\n   *   password credentials.\n   * @returns A promise that resolves when\n   *   the operation completes with the result of the import. This includes the\n   *   number of successful imports, the number of failed imports and their\n   *   corresponding errors.\n  */\n\n\n  BaseAuth.prototype.importUsers = function (users, options) {\n    return this.authRequestHandler.uploadAccount(users, options);\n  };\n  /**\n   * Creates a new Firebase session cookie with the specified options. The created\n   * JWT string can be set as a server-side session cookie with a custom cookie\n   * policy, and be used for session management. The session cookie JWT will have\n   * the same payload claims as the provided ID token.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies | Manage Session Cookies}\n   * for code samples and detailed documentation.\n   *\n   * @param idToken - The Firebase ID token to exchange for a session\n   *   cookie.\n   * @param sessionCookieOptions - The session\n   *   cookie options which includes custom session duration.\n   *\n   * @returns A promise that resolves on success with the\n   *   created session cookie.\n   */\n\n\n  BaseAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n    // Return rejected promise if expiresIn is not available.\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    }\n\n    return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n  };\n  /**\n   * Verifies a Firebase session cookie. Returns a Promise with the cookie claims.\n   * Rejects the promise if the cookie could not be verified.\n   *\n   * If `checkRevoked` is set to true, first verifies whether the corresponding\n   * user is disabled: If yes, an `auth/user-disabled` error is thrown. If no,\n   * verifies if the session corresponding to the session cookie was revoked.\n   * If the corresponding user's session was invalidated, an\n   * `auth/session-cookie-revoked` error is thrown. If not specified the check\n   * is not performed.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies#verify_session_cookie_and_check_permissions |\n   * Verify Session Cookies}\n   * for code samples and detailed documentation\n   *\n   * @param sessionCookie - The session cookie to verify.\n   * @param checkForRevocation -  Whether to check if the session cookie was\n   *   revoked. This requires an extra request to the Firebase Auth backend to\n   *   check the `tokensValidAfterTime` time for the corresponding user.\n   *   When not specified, this additional check is not performed.\n   *\n   * @returns A promise fulfilled with the\n   *   session cookie's decoded claims if the session cookie is valid; otherwise,\n   *   a rejected promise.\n   */\n\n\n  BaseAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    var isEmulator = auth_api_request_1.useEmulator();\n    return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator).then(function (decodedIdToken) {\n      // Whether to check if the token was revoked.\n      if (checkRevoked || isEmulator) {\n        return _this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n      }\n\n      return decodedIdToken;\n    });\n  };\n  /**\n   * Generates the out of band email action link to reset a user's password.\n   * The link is generated for the user with the specified email address. The\n   * optional  {@link ActionCodeSettings} object\n   * defines whether the link is to be handled by a mobile app or browser and the\n   * additional state information to be passed in the deep link, etc.\n   *\n   * @example\n   * ```javascript\n   * var actionCodeSettings = {\n   *   url: 'https://www.example.com/?email=user@example.com',\n   *   iOS: {\n   *     bundleId: 'com.example.ios'\n   *   },\n   *   android: {\n   *     packageName: 'com.example.android',\n   *     installApp: true,\n   *     minimumVersion: '12'\n   *   },\n   *   handleCodeInApp: true,\n   *   dynamicLinkDomain: 'custom.page.link'\n   * };\n   * admin.auth()\n   *     .generatePasswordResetLink('user@example.com', actionCodeSettings)\n   *     .then(function(link) {\n   *       // The link was successfully generated.\n   *     })\n   *     .catch(function(error) {\n   *       // Some error occurred, you can inspect the code: error.code\n   *     });\n   * ```\n   *\n   * @param email - The email address of the user whose password is to be\n   *   reset.\n   * @param actionCodeSettings - The action\n   *     code settings. If specified, the state/continue URL is set as the\n   *     \"continueUrl\" parameter in the password reset link. The default password\n   *     reset landing page will use this to display a link to go back to the app\n   *     if it is installed.\n   *     If the actionCodeSettings is not specified, no URL is appended to the\n   *     action URL.\n   *     The state URL provided must belong to a domain that is whitelisted by the\n   *     developer in the console. Otherwise an error is thrown.\n   *     Mobile app redirects are only applicable if the developer configures\n   *     and accepts the Firebase Dynamic Links terms of service.\n   *     The Android package name and iOS bundle ID are respected only if they\n   *     are configured in the same Firebase Auth project.\n   * @returns A promise that resolves with the generated link.\n   */\n\n\n  BaseAuth.prototype.generatePasswordResetLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n  };\n  /**\n   * Generates the out of band email action link to verify the user's ownership\n   * of the specified email. The {@link ActionCodeSettings} object provided\n   * as an argument to this method defines whether the link is to be handled by a\n   * mobile app or browser along with additional state information to be passed in\n   * the deep link, etc.\n   *\n   * @example\n   * ```javascript\n   * var actionCodeSettings = {\n   *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\n   *   iOS: {\n   *     bundleId: 'com.example.ios'\n   *   },\n   *   android: {\n   *     packageName: 'com.example.android',\n   *     installApp: true,\n   *     minimumVersion: '12'\n   *   },\n   *   handleCodeInApp: true,\n   *   dynamicLinkDomain: 'custom.page.link'\n   * };\n   * admin.auth()\n   *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\n   *     .then(function(link) {\n   *       // The link was successfully generated.\n   *     })\n   *     .catch(function(error) {\n   *       // Some error occurred, you can inspect the code: error.code\n   *     });\n   * ```\n   *\n   * @param email - The email account to verify.\n   * @param actionCodeSettings - The action\n   *     code settings. If specified, the state/continue URL is set as the\n   *     \"continueUrl\" parameter in the email verification link. The default email\n   *     verification landing page will use this to display a link to go back to\n   *     the app if it is installed.\n   *     If the actionCodeSettings is not specified, no URL is appended to the\n   *     action URL.\n   *     The state URL provided must belong to a domain that is whitelisted by the\n   *     developer in the console. Otherwise an error is thrown.\n   *     Mobile app redirects are only applicable if the developer configures\n   *     and accepts the Firebase Dynamic Links terms of service.\n   *     The Android package name and iOS bundle ID are respected only if they\n   *     are configured in the same Firebase Auth project.\n   * @returns A promise that resolves with the generated link.\n   */\n\n\n  BaseAuth.prototype.generateEmailVerificationLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n  };\n  /**\n   * Generates the out of band email action link to verify the user's ownership\n   * of the specified email. The {@link ActionCodeSettings} object provided\n   * as an argument to this method defines whether the link is to be handled by a\n   * mobile app or browser along with additional state information to be passed in\n   * the deep link, etc.\n   *\n   * @example\n   * ```javascript\n   * var actionCodeSettings = {\n   *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\n   *   iOS: {\n   *     bundleId: 'com.example.ios'\n   *   },\n   *   android: {\n   *     packageName: 'com.example.android',\n   *     installApp: true,\n   *     minimumVersion: '12'\n   *   },\n   *   handleCodeInApp: true,\n   *   dynamicLinkDomain: 'custom.page.link'\n   * };\n   * admin.auth()\n   *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\n   *     .then(function(link) {\n   *       // The link was successfully generated.\n   *     })\n   *     .catch(function(error) {\n   *       // Some error occurred, you can inspect the code: error.code\n   *     });\n   * ```\n   *\n   * @param email - The email account to verify.\n   * @param actionCodeSettings - The action\n   *     code settings. If specified, the state/continue URL is set as the\n   *     \"continueUrl\" parameter in the email verification link. The default email\n   *     verification landing page will use this to display a link to go back to\n   *     the app if it is installed.\n   *     If the actionCodeSettings is not specified, no URL is appended to the\n   *     action URL.\n   *     The state URL provided must belong to a domain that is whitelisted by the\n   *     developer in the console. Otherwise an error is thrown.\n   *     Mobile app redirects are only applicable if the developer configures\n   *     and accepts the Firebase Dynamic Links terms of service.\n   *     The Android package name and iOS bundle ID are respected only if they\n   *     are configured in the same Firebase Auth project.\n   * @returns A promise that resolves with the generated link.\n   */\n\n\n  BaseAuth.prototype.generateSignInWithEmailLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n  };\n  /**\n   * Returns the list of existing provider configurations matching the filter\n   * provided. At most, 100 provider configs can be listed at a time.\n   *\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\n   * (GCIP). To learn more about GCIP, including pricing and features,\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n   *\n   * @param options - The provider config filter to apply.\n   * @returns A promise that resolves with the list of provider configs meeting the\n   *   filter requirements.\n   */\n\n\n  BaseAuth.prototype.listProviderConfigs = function (options) {\n    var processResponse = function (response, providerConfigs) {\n      // Return list of provider configuration and the next page token if available.\n      var result = {\n        providerConfigs: providerConfigs\n      }; // Delete result.pageToken if undefined.\n\n      if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {\n        result.pageToken = response.nextPageToken;\n      }\n\n      return result;\n    };\n\n    if (options && options.type === 'oidc') {\n      return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken).then(function (response) {\n        // List of provider configurations to return.\n        var providerConfigs = []; // Convert each provider config response to a OIDCConfig.\n\n        response.oauthIdpConfigs.forEach(function (configResponse) {\n          providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\n        }); // Return list of provider configuration and the next page token if available.\n\n        return processResponse(response, providerConfigs);\n      });\n    } else if (options && options.type === 'saml') {\n      return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken).then(function (response) {\n        // List of provider configurations to return.\n        var providerConfigs = []; // Convert each provider config response to a SAMLConfig.\n\n        response.inboundSamlConfigs.forEach(function (configResponse) {\n          providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\n        }); // Return list of provider configuration and the next page token if available.\n\n        return processResponse(response, providerConfigs);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"AuthProviderConfigFilter.type\" must be either \"saml\" or \"oidc\"'));\n  };\n  /**\n   * Looks up an Auth provider configuration by the provided ID.\n   * Returns a promise that resolves with the provider configuration\n   * corresponding to the provider ID specified. If the specified ID does not\n   * exist, an `auth/configuration-not-found` error is thrown.\n   *\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\n   * (GCIP). To learn more about GCIP, including pricing and features,\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n   *\n   * @param providerId - The provider ID corresponding to the provider\n   *     config to return.\n   * @returns A promise that resolves\n   *     with the configuration corresponding to the provided ID.\n   */\n\n\n  BaseAuth.prototype.getProviderConfig = function (providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getOAuthIdpConfig(providerId).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getInboundSamlConfig(providerId).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Deletes the provider configuration corresponding to the provider ID passed.\n   * If the specified ID does not exist, an `auth/configuration-not-found` error\n   * is thrown.\n   *\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\n   * (GCIP). To learn more about GCIP, including pricing and features,\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n   *\n   * @param providerId - The provider ID corresponding to the provider\n   *     config to delete.\n   * @returns A promise that resolves on completion.\n   */\n\n\n  BaseAuth.prototype.deleteProviderConfig = function (providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteInboundSamlConfig(providerId);\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Returns a promise that resolves with the updated `AuthProviderConfig`\n   * corresponding to the provider ID specified.\n   * If the specified ID does not exist, an `auth/configuration-not-found` error\n   * is thrown.\n   *\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\n   * (GCIP). To learn more about GCIP, including pricing and features,\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n   *\n   * @param providerId - The provider ID corresponding to the provider\n   *     config to update.\n   * @param updatedConfig - The updated configuration.\n   * @returns A promise that resolves with the updated provider configuration.\n   */\n\n\n  BaseAuth.prototype.updateProviderConfig = function (providerId, updatedConfig) {\n    if (!validator.isNonNullObject(updatedConfig)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\n    }\n\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Returns a promise that resolves with the newly created `AuthProviderConfig`\n   * when the new provider configuration is created.\n   *\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\n   * (GCIP). To learn more about GCIP, including pricing and features,\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n   *\n   * @param config - The provider configuration to create.\n   * @returns A promise that resolves with the created provider configuration.\n   */\n\n\n  BaseAuth.prototype.createProviderConfig = function (config) {\n    if (!validator.isNonNullObject(config)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\n    }\n\n    if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createOAuthIdpConfig(config).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createInboundSamlConfig(config).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Verifies the decoded Firebase issued JWT is not revoked or disabled. Returns a promise that\n   * resolves with the decoded claims on success. Rejects the promise with revocation error if revoked\n   * or user disabled.\n   *\n   * @param decodedIdToken - The JWT's decoded claims.\n   * @param revocationErrorInfo - The revocation error info to throw on revocation\n   *     detection.\n   * @returns A promise that will be fulfilled after a successful verification.\n   */\n\n\n  BaseAuth.prototype.verifyDecodedJWTNotRevokedOrDisabled = function (decodedIdToken, revocationErrorInfo) {\n    // Get tokens valid after time for the corresponding user.\n    return this.getUser(decodedIdToken.sub).then(function (user) {\n      if (user.disabled) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_DISABLED, 'The user record is disabled.');\n      } // If no tokens valid after time available, token is not revoked.\n\n\n      if (user.tokensValidAfterTime) {\n        // Get the ID token authentication time and convert to milliseconds UTC.\n        var authTimeUtc = decodedIdToken.auth_time * 1000; // Get user tokens valid after time in milliseconds UTC.\n\n        var validSinceUtc = new Date(user.tokensValidAfterTime).getTime(); // Check if authentication time is older than valid since time.\n\n        if (authTimeUtc < validSinceUtc) {\n          throw new error_1.FirebaseAuthError(revocationErrorInfo);\n        }\n      } // All checks above passed. Return the decoded token.\n\n\n      return decodedIdToken;\n    });\n  };\n\n  return BaseAuth;\n}();\n\nexports.BaseAuth = BaseAuth;","map":{"version":3,"sources":["/Users/zarashipchandler/git_dir/TPEO/Week_6/homework/frontend/node_modules/firebase-admin/lib/auth/base-auth.js"],"names":["Object","defineProperty","exports","value","BaseAuth","createFirebaseTokenGenerator","error_1","require","deep_copy_1","validator","auth_api_request_1","token_generator_1","token_verifier_1","auth_config_1","user_record_1","identifier_1","crypto_signer_1","app","tenantId","signer","useEmulator","EmulatedSigner","cryptoSignerFromApp","FirebaseTokenGenerator","err","handleCryptoSignerError","authRequestHandler","tokenGenerator","sessionCookieVerifier","createSessionCookieVerifier","idTokenVerifier","createIdTokenVerifier","prototype","createCustomToken","uid","developerClaims","verifyIdToken","idToken","checkRevoked","_this","isEmulator","verifyJWT","then","decodedIdToken","verifyDecodedJWTNotRevokedOrDisabled","AuthClientErrorCode","ID_TOKEN_REVOKED","getUser","getAccountInfoByUid","response","UserRecord","users","getUserByEmail","email","getAccountInfoByEmail","getUserByPhoneNumber","phoneNumber","getAccountInfoByPhoneNumber","getUserByProviderUid","providerId","getAccountInfoByFederatedUid","getUsers","identifiers","isArray","FirebaseAuthError","INVALID_ARGUMENT","getAccountInfoByIdentifiers","isUserFound","id","userRecords","find","userRecord","isUidIdentifier","isEmailIdentifier","isPhoneIdentifier","isProviderIdentifier","matchingUserInfo","providerData","userInfo","providerUid","INTERNAL_ERROR","map","user","notFound","filter","listUsers","maxResults","pageToken","downloadAccount","forEach","userResponse","push","result","nextPageToken","createUser","properties","createNewAccount","catch","error","code","deleteUser","deleteAccount","deleteUsers","uids","deleteAccounts","batchDeleteAccountsResponse","failureCount","successCount","length","errors","isNonEmptyArray","batchDeleteErrorInfo","index","undefined","errMsgToError","msg","startsWith","USER_NOT_DISABLED","message","updateUser","deepCopy","providerToLink","providersToUnlink","indexOf","updateExistingAccount","existingUid","setCustomUserClaims","customUserClaims","revokeRefreshTokens","importUsers","options","uploadAccount","createSessionCookie","sessionCookieOptions","isNonNullObject","isNumber","expiresIn","Promise","reject","INVALID_SESSION_COOKIE_DURATION","verifySessionCookie","sessionCookie","SESSION_COOKIE_REVOKED","generatePasswordResetLink","actionCodeSettings","getEmailActionLink","generateEmailVerificationLink","generateSignInWithEmailLink","listProviderConfigs","processResponse","providerConfigs","hasOwnProperty","call","type","listOAuthIdpConfigs","oauthIdpConfigs","configResponse","OIDCConfig","listInboundSamlConfigs","inboundSamlConfigs","SAMLConfig","getProviderConfig","isProviderId","getOAuthIdpConfig","getInboundSamlConfig","INVALID_PROVIDER_ID","deleteProviderConfig","deleteOAuthIdpConfig","deleteInboundSamlConfig","updateProviderConfig","updatedConfig","INVALID_CONFIG","updateOAuthIdpConfig","updateInboundSamlConfig","createProviderConfig","config","createOAuthIdpConfig","createInboundSamlConfig","revocationErrorInfo","sub","disabled","USER_DISABLED","tokensValidAfterTime","authTimeUtc","auth_time","validSinceUtc","Date","getTime"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,QAAR,GAAmBF,OAAO,CAACG,4BAAR,GAAuC,KAAK,CAA/D;;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,oBAAD,CAAzB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,oBAAD,CAAvB;;AACA,IAAIG,kBAAkB,GAAGH,OAAO,CAAC,oBAAD,CAAhC;;AACA,IAAII,iBAAiB,GAAGJ,OAAO,CAAC,mBAAD,CAA/B;;AACA,IAAIK,gBAAgB,GAAGL,OAAO,CAAC,kBAAD,CAA9B;;AACA,IAAIM,aAAa,GAAGN,OAAO,CAAC,eAAD,CAA3B;;AACA,IAAIO,aAAa,GAAGP,OAAO,CAAC,eAAD,CAA3B;;AACA,IAAIQ,YAAY,GAAGR,OAAO,CAAC,cAAD,CAA1B;;AACA,IAAIS,eAAe,GAAGT,OAAO,CAAC,wBAAD,CAA7B;AACA;AACA;AACA;;;AACA,SAASF,4BAAT,CAAsCY,GAAtC,EAA2CC,QAA3C,EAAqD;AACjD,MAAI;AACA,QAAIC,MAAM,GAAGT,kBAAkB,CAACU,WAAnB,KAAmC,IAAIT,iBAAiB,CAACU,cAAtB,EAAnC,GAA4EL,eAAe,CAACM,mBAAhB,CAAoCL,GAApC,CAAzF;AACA,WAAO,IAAIN,iBAAiB,CAACY,sBAAtB,CAA6CJ,MAA7C,EAAqDD,QAArD,CAAP;AACH,GAHD,CAIA,OAAOM,GAAP,EAAY;AACR,UAAMb,iBAAiB,CAACc,uBAAlB,CAA0CD,GAA1C,CAAN;AACH;AACJ;;AACDtB,OAAO,CAACG,4BAAR,GAAuCA,4BAAvC;AACA;AACA;AACA;;AACA,IAAID,QAAQ;AAAG;AAAe,YAAY;AACtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,WAASA,QAAT,CAAkBa,GAAlB;AACA;AAAiBS,EAAAA,kBADjB,EACqCC,cADrC,EACqD;AACjD,SAAKD,kBAAL,GAA0BA,kBAA1B;;AACA,QAAIC,cAAJ,EAAoB;AAChB,WAAKA,cAAL,GAAsBA,cAAtB;AACH,KAFD,MAGK;AACD,WAAKA,cAAL,GAAsBtB,4BAA4B,CAACY,GAAD,CAAlD;AACH;;AACD,SAAKW,qBAAL,GAA6BhB,gBAAgB,CAACiB,2BAAjB,CAA6CZ,GAA7C,CAA7B;AACA,SAAKa,eAAL,GAAuBlB,gBAAgB,CAACmB,qBAAjB,CAAuCd,GAAvC,CAAvB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIb,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBC,iBAAnB,GAAuC,UAAUC,GAAV,EAAeC,eAAf,EAAgC;AACnE,WAAO,KAAKR,cAAL,CAAoBM,iBAApB,CAAsCC,GAAtC,EAA2CC,eAA3C,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/B,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBI,aAAnB,GAAmC,UAAUC,OAAV,EAAmBC,YAAnB,EAAiC;AAChE,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAID,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAAEA,MAAAA,YAAY,GAAG,KAAf;AAAuB;;AACtD,QAAIE,UAAU,GAAG9B,kBAAkB,CAACU,WAAnB,EAAjB;AACA,WAAO,KAAKU,eAAL,CAAqBW,SAArB,CAA+BJ,OAA/B,EAAwCG,UAAxC,EACFE,IADE,CACG,UAAUC,cAAV,EAA0B;AAChC;AACA,UAAIL,YAAY,IAAIE,UAApB,EAAgC;AAC5B,eAAOD,KAAK,CAACK,oCAAN,CAA2CD,cAA3C,EAA2DrC,OAAO,CAACuC,mBAAR,CAA4BC,gBAAvF,CAAP;AACH;;AACD,aAAOH,cAAP;AACH,KAPM,CAAP;AAQH,GAZD;AAaA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIvC,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBe,OAAnB,GAA6B,UAAUb,GAAV,EAAe;AACxC,WAAO,KAAKR,kBAAL,CAAwBsB,mBAAxB,CAA4Cd,GAA5C,EACFQ,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,aAAO,IAAInC,aAAa,CAACoC,UAAlB,CAA6BD,QAAQ,CAACE,KAAT,CAAe,CAAf,CAA7B,CAAP;AACH,KAJM,CAAP;AAKH,GAND;AAOA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/C,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBoB,cAAnB,GAAoC,UAAUC,KAAV,EAAiB;AACjD,WAAO,KAAK3B,kBAAL,CAAwB4B,qBAAxB,CAA8CD,KAA9C,EACFX,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,aAAO,IAAInC,aAAa,CAACoC,UAAlB,CAA6BD,QAAQ,CAACE,KAAT,CAAe,CAAf,CAA7B,CAAP;AACH,KAJM,CAAP;AAKH,GAND;AAOA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/C,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBuB,oBAAnB,GAA0C,UAAUC,WAAV,EAAuB;AAC7D,WAAO,KAAK9B,kBAAL,CAAwB+B,2BAAxB,CAAoDD,WAApD,EACFd,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,aAAO,IAAInC,aAAa,CAACoC,UAAlB,CAA6BD,QAAQ,CAACE,KAAT,CAAe,CAAf,CAA7B,CAAP;AACH,KAJM,CAAP;AAKH,GAND;AAOA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/C,EAAAA,QAAQ,CAAC4B,SAAT,CAAmB0B,oBAAnB,GAA0C,UAAUC,UAAV,EAAsBzB,GAAtB,EAA2B;AACjE;AACA;AACA;AACA,QAAIyB,UAAU,KAAK,OAAnB,EAA4B;AACxB,aAAO,KAAKJ,oBAAL,CAA0BrB,GAA1B,CAAP;AACH,KAFD,MAGK,IAAIyB,UAAU,KAAK,OAAnB,EAA4B;AAC7B,aAAO,KAAKP,cAAL,CAAoBlB,GAApB,CAAP;AACH;;AACD,WAAO,KAAKR,kBAAL,CAAwBkC,4BAAxB,CAAqDD,UAArD,EAAiEzB,GAAjE,EACFQ,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,aAAO,IAAInC,aAAa,CAACoC,UAAlB,CAA6BD,QAAQ,CAACE,KAAT,CAAe,CAAf,CAA7B,CAAP;AACH,KAJM,CAAP;AAKH,GAfD;AAgBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/C,EAAAA,QAAQ,CAAC4B,SAAT,CAAmB6B,QAAnB,GAA8B,UAAUC,WAAV,EAAuB;AACjD,QAAI,CAACrD,SAAS,CAACsD,OAAV,CAAkBD,WAAlB,CAAL,EAAqC;AACjC,YAAM,IAAIxD,OAAO,CAAC0D,iBAAZ,CAA8B1D,OAAO,CAACuC,mBAAR,CAA4BoB,gBAA1D,EAA4E,0CAA5E,CAAN;AACH;;AACD,WAAO,KAAKvC,kBAAL,CACFwC,2BADE,CAC0BJ,WAD1B,EAEFpB,IAFE,CAEG,UAAUO,QAAV,EAAoB;AAC1B;AACZ;AACA;AACA;AACY,UAAIkB,WAAW,GAAI,UAAUC,EAAV,EAAcC,WAAd,EAA2B;AAC1C,eAAO,CAAC,CAACA,WAAW,CAACC,IAAZ,CAAiB,UAAUC,UAAV,EAAsB;AAC5C,cAAIxD,YAAY,CAACyD,eAAb,CAA6BJ,EAA7B,CAAJ,EAAsC;AAClC,mBAAOA,EAAE,CAAClC,GAAH,KAAWqC,UAAU,CAACrC,GAA7B;AACH,WAFD,MAGK,IAAInB,YAAY,CAAC0D,iBAAb,CAA+BL,EAA/B,CAAJ,EAAwC;AACzC,mBAAOA,EAAE,CAACf,KAAH,KAAakB,UAAU,CAAClB,KAA/B;AACH,WAFI,MAGA,IAAItC,YAAY,CAAC2D,iBAAb,CAA+BN,EAA/B,CAAJ,EAAwC;AACzC,mBAAOA,EAAE,CAACZ,WAAH,KAAmBe,UAAU,CAACf,WAArC;AACH,WAFI,MAGA,IAAIzC,YAAY,CAAC4D,oBAAb,CAAkCP,EAAlC,CAAJ,EAA2C;AAC5C,gBAAIQ,gBAAgB,GAAGL,UAAU,CAACM,YAAX,CAAwBP,IAAxB,CAA6B,UAAUQ,QAAV,EAAoB;AACpE,qBAAOV,EAAE,CAACT,UAAH,KAAkBmB,QAAQ,CAACnB,UAAlC;AACH,aAFsB,CAAvB;AAGA,mBAAO,CAAC,CAACiB,gBAAF,IAAsBR,EAAE,CAACW,WAAH,KAAmBH,gBAAgB,CAAC1C,GAAjE;AACH,WALI,MAMA;AACD,kBAAM,IAAI5B,OAAO,CAAC0D,iBAAZ,CAA8B1D,OAAO,CAACuC,mBAAR,CAA4BmC,cAA1D,EAA0E,2BAA1E,CAAN;AACH;AACJ,SAnBQ,CAAT;AAoBH,OArBD;;AAsBA,UAAI7B,KAAK,GAAGF,QAAQ,CAACE,KAAT,GAAiBF,QAAQ,CAACE,KAAT,CAAe8B,GAAf,CAAmB,UAAUC,IAAV,EAAgB;AAAE,eAAO,IAAIpE,aAAa,CAACoC,UAAlB,CAA6BgC,IAA7B,CAAP;AAA4C,OAAjF,CAAjB,GAAsG,EAAlH;AACA,UAAIC,QAAQ,GAAGrB,WAAW,CAACsB,MAAZ,CAAmB,UAAUhB,EAAV,EAAc;AAAE,eAAO,CAACD,WAAW,CAACC,EAAD,EAAKjB,KAAL,CAAnB;AAAiC,OAApE,CAAf;AACA,aAAO;AAAEA,QAAAA,KAAK,EAAEA,KAAT;AAAgBgC,QAAAA,QAAQ,EAAEA;AAA1B,OAAP;AACH,KAhCM,CAAP;AAiCH,GArCD;AAsCA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/E,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBqD,SAAnB,GAA+B,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AAC5D,WAAO,KAAK7D,kBAAL,CAAwB8D,eAAxB,CAAwCF,UAAxC,EAAoDC,SAApD,EACF7C,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,UAAIE,KAAK,GAAG,EAAZ,CAF0B,CAG1B;;AACAF,MAAAA,QAAQ,CAACE,KAAT,CAAesC,OAAf,CAAuB,UAAUC,YAAV,EAAwB;AAC3CvC,QAAAA,KAAK,CAACwC,IAAN,CAAW,IAAI7E,aAAa,CAACoC,UAAlB,CAA6BwC,YAA7B,CAAX;AACH,OAFD,EAJ0B,CAO1B;;AACA,UAAIE,MAAM,GAAG;AACTzC,QAAAA,KAAK,EAAEA,KADE;AAEToC,QAAAA,SAAS,EAAEtC,QAAQ,CAAC4C;AAFX,OAAb,CAR0B,CAY1B;;AACA,UAAI,OAAOD,MAAM,CAACL,SAAd,KAA4B,WAAhC,EAA6C;AACzC,eAAOK,MAAM,CAACL,SAAd;AACH;;AACD,aAAOK,MAAP;AACH,KAlBM,CAAP;AAmBH,GApBD;AAqBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIxF,EAAAA,QAAQ,CAAC4B,SAAT,CAAmB8D,UAAnB,GAAgC,UAAUC,UAAV,EAAsB;AAClD,QAAIxD,KAAK,GAAG,IAAZ;;AACA,WAAO,KAAKb,kBAAL,CAAwBsE,gBAAxB,CAAyCD,UAAzC,EACFrD,IADE,CACG,UAAUR,GAAV,EAAe;AACrB;AACA,aAAOK,KAAK,CAACQ,OAAN,CAAcb,GAAd,CAAP;AACH,KAJM,EAKF+D,KALE,CAKI,UAAUC,KAAV,EAAiB;AACxB,UAAIA,KAAK,CAACC,IAAN,KAAe,qBAAnB,EAA0C;AACtC;AACA,cAAM,IAAI7F,OAAO,CAAC0D,iBAAZ,CAA8B1D,OAAO,CAACuC,mBAAR,CAA4BmC,cAA1D,EAA0E,4CAA1E,CAAN;AACH;;AACD,YAAMkB,KAAN;AACH,KAXM,CAAP;AAYH,GAdD;AAeA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI9F,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBoE,UAAnB,GAAgC,UAAUlE,GAAV,EAAe;AAC3C,WAAO,KAAKR,kBAAL,CAAwB2E,aAAxB,CAAsCnE,GAAtC,EACFQ,IADE,CACG,YAAY,CAClB;AACH,KAHM,CAAP;AAIH,GALD;AAMA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACItC,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBsE,WAAnB,GAAiC,UAAUC,IAAV,EAAgB;AAC7C,QAAI,CAAC9F,SAAS,CAACsD,OAAV,CAAkBwC,IAAlB,CAAL,EAA8B;AAC1B,YAAM,IAAIjG,OAAO,CAAC0D,iBAAZ,CAA8B1D,OAAO,CAACuC,mBAAR,CAA4BoB,gBAA1D,EAA4E,mCAA5E,CAAN;AACH;;AACD,WAAO,KAAKvC,kBAAL,CAAwB8E,cAAxB,CAAuCD,IAAvC;AAA6C;AAAW,QAAxD,EACF7D,IADE,CACG,UAAU+D,2BAAV,EAAuC;AAC7C,UAAIb,MAAM,GAAG;AACTc,QAAAA,YAAY,EAAE,CADL;AAETC,QAAAA,YAAY,EAAEJ,IAAI,CAACK,MAFV;AAGTC,QAAAA,MAAM,EAAE;AAHC,OAAb;;AAKA,UAAI,CAACpG,SAAS,CAACqG,eAAV,CAA0BL,2BAA2B,CAACI,MAAtD,CAAL,EAAoE;AAChE,eAAOjB,MAAP;AACH;;AACDA,MAAAA,MAAM,CAACc,YAAP,GAAsBD,2BAA2B,CAACI,MAA5B,CAAmCD,MAAzD;AACAhB,MAAAA,MAAM,CAACe,YAAP,GAAsBJ,IAAI,CAACK,MAAL,GAAcH,2BAA2B,CAACI,MAA5B,CAAmCD,MAAvE;AACAhB,MAAAA,MAAM,CAACiB,MAAP,GAAgBJ,2BAA2B,CAACI,MAA5B,CAAmC5B,GAAnC,CAAuC,UAAU8B,oBAAV,EAAgC;AACnF,YAAIA,oBAAoB,CAACC,KAArB,KAA+BC,SAAnC,EAA8C;AAC1C,gBAAM,IAAI3G,OAAO,CAAC0D,iBAAZ,CAA8B1D,OAAO,CAACuC,mBAAR,CAA4BmC,cAA1D,EAA0E,8CAA1E,CAAN;AACH;;AACD,YAAIkC,aAAa,GAAG,UAAUC,GAAV,EAAe;AAC/B;AACA;AACA,cAAIhB,IAAI,GAAGgB,GAAG,IAAIA,GAAG,CAACC,UAAJ,CAAe,cAAf,CAAP,GACP9G,OAAO,CAACuC,mBAAR,CAA4BwE,iBADrB,GACyC/G,OAAO,CAACuC,mBAAR,CAA4BmC,cADhF;AAEA,iBAAO,IAAI1E,OAAO,CAAC0D,iBAAZ,CAA8BmC,IAA9B,EAAoCY,oBAAoB,CAACO,OAAzD,CAAP;AACH,SAND;;AAOA,eAAO;AACHN,UAAAA,KAAK,EAAED,oBAAoB,CAACC,KADzB;AAEHd,UAAAA,KAAK,EAAEgB,aAAa,CAACH,oBAAoB,CAACO,OAAtB;AAFjB,SAAP;AAIH,OAfe,CAAhB;AAgBA,aAAO1B,MAAP;AACH,KA7BM,CAAP;AA8BH,GAlCD;AAmCA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIxF,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBuF,UAAnB,GAAgC,UAAUrF,GAAV,EAAe6D,UAAf,EAA2B;AACvD,QAAIxD,KAAK,GAAG,IAAZ,CADuD,CAEvD;AACA;AACA;AACA;AACA;AACA;;;AACAwD,IAAAA,UAAU,GAAGvF,WAAW,CAACgH,QAAZ,CAAqBzB,UAArB,CAAb;;AACA,QAAIA,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAAC0B,cAAvE,EAAuF;AACnF,UAAI1B,UAAU,CAAC0B,cAAX,CAA0B9D,UAA1B,KAAyC,OAA7C,EAAsD;AAClD,YAAI,OAAOoC,UAAU,CAAC1C,KAAlB,KAA4B,WAAhC,EAA6C;AACzC,gBAAM,IAAI/C,OAAO,CAAC0D,iBAAZ,CAA8B1D,OAAO,CAACuC,mBAAR,CAA4BoB,gBAA1D,EAA4E,+FAC5E,kFADA,CAAN;AAEH;;AACD8B,QAAAA,UAAU,CAAC1C,KAAX,GAAmB0C,UAAU,CAAC0B,cAAX,CAA0BvF,GAA7C;AACA,eAAO6D,UAAU,CAAC0B,cAAlB;AACH,OAPD,MAQK,IAAI1B,UAAU,CAAC0B,cAAX,CAA0B9D,UAA1B,KAAyC,OAA7C,EAAsD;AACvD,YAAI,OAAOoC,UAAU,CAACvC,WAAlB,KAAkC,WAAtC,EAAmD;AAC/C,gBAAM,IAAIlD,OAAO,CAAC0D,iBAAZ,CAA8B1D,OAAO,CAACuC,mBAAR,CAA4BoB,gBAA1D,EAA4E,qGAC5E,6EADA,CAAN;AAEH;;AACD8B,QAAAA,UAAU,CAACvC,WAAX,GAAyBuC,UAAU,CAAC0B,cAAX,CAA0BvF,GAAnD;AACA,eAAO6D,UAAU,CAAC0B,cAAlB;AACH;AACJ;;AACD,QAAI1B,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAAC2B,iBAAvE,EAA0F;AACtF,UAAI3B,UAAU,CAAC2B,iBAAX,CAA6BC,OAA7B,CAAqC,OAArC,MAAkD,CAAC,CAAvD,EAA0D;AACtD;AACA;AACA;AACA;AACA,YAAI5B,UAAU,CAACvC,WAAX,KAA2B,IAA/B,EAAqC;AACjC,gBAAM,IAAIlD,OAAO,CAAC0D,iBAAZ,CAA8B1D,OAAO,CAACuC,mBAAR,CAA4BoB,gBAA1D,EAA4E,oGAC5E,sFADA,CAAN;AAEH;AACJ;AACJ;;AACD,WAAO,KAAKvC,kBAAL,CAAwBkG,qBAAxB,CAA8C1F,GAA9C,EAAmD6D,UAAnD,EACFrD,IADE,CACG,UAAUmF,WAAV,EAAuB;AAC7B;AACA,aAAOtF,KAAK,CAACQ,OAAN,CAAc8E,WAAd,CAAP;AACH,KAJM,CAAP;AAKH,GA5CD;AA6CA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIzH,EAAAA,QAAQ,CAAC4B,SAAT,CAAmB8F,mBAAnB,GAAyC,UAAU5F,GAAV,EAAe6F,gBAAf,EAAiC;AACtE,WAAO,KAAKrG,kBAAL,CAAwBoG,mBAAxB,CAA4C5F,GAA5C,EAAiD6F,gBAAjD,EACFrF,IADE,CACG,YAAY,CAClB;AACH,KAHM,CAAP;AAIH,GALD;AAMA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACItC,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBgG,mBAAnB,GAAyC,UAAU9F,GAAV,EAAe;AACpD,WAAO,KAAKR,kBAAL,CAAwBsG,mBAAxB,CAA4C9F,GAA5C,EACFQ,IADE,CACG,YAAY,CAClB;AACH,KAHM,CAAP;AAIH,GALD;AAMA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACItC,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBiG,WAAnB,GAAiC,UAAU9E,KAAV,EAAiB+E,OAAjB,EAA0B;AACvD,WAAO,KAAKxG,kBAAL,CAAwByG,aAAxB,CAAsChF,KAAtC,EAA6C+E,OAA7C,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI9H,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBoG,mBAAnB,GAAyC,UAAU/F,OAAV,EAAmBgG,oBAAnB,EAAyC;AAC9E;AACA,QAAI,CAAC5H,SAAS,CAAC6H,eAAV,CAA0BD,oBAA1B,CAAD,IACA,CAAC5H,SAAS,CAAC8H,QAAV,CAAmBF,oBAAoB,CAACG,SAAxC,CADL,EACyD;AACrD,aAAOC,OAAO,CAACC,MAAR,CAAe,IAAIpI,OAAO,CAAC0D,iBAAZ,CAA8B1D,OAAO,CAACuC,mBAAR,CAA4B8F,+BAA1D,CAAf,CAAP;AACH;;AACD,WAAO,KAAKjH,kBAAL,CAAwB0G,mBAAxB,CAA4C/F,OAA5C,EAAqDgG,oBAAoB,CAACG,SAA1E,CAAP;AACH,GAPD;AAQA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIpI,EAAAA,QAAQ,CAAC4B,SAAT,CAAmB4G,mBAAnB,GAAyC,UAAUC,aAAV,EAAyBvG,YAAzB,EAAuC;AAC5E,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAID,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAAEA,MAAAA,YAAY,GAAG,KAAf;AAAuB;;AACtD,QAAIE,UAAU,GAAG9B,kBAAkB,CAACU,WAAnB,EAAjB;AACA,WAAO,KAAKQ,qBAAL,CAA2Ba,SAA3B,CAAqCoG,aAArC,EAAoDrG,UAApD,EACFE,IADE,CACG,UAAUC,cAAV,EAA0B;AAChC;AACA,UAAIL,YAAY,IAAIE,UAApB,EAAgC;AAC5B,eAAOD,KAAK,CAACK,oCAAN,CAA2CD,cAA3C,EAA2DrC,OAAO,CAACuC,mBAAR,CAA4BiG,sBAAvF,CAAP;AACH;;AACD,aAAOnG,cAAP;AACH,KAPM,CAAP;AAQH,GAZD;AAaA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIvC,EAAAA,QAAQ,CAAC4B,SAAT,CAAmB+G,yBAAnB,GAA+C,UAAU1F,KAAV,EAAiB2F,kBAAjB,EAAqC;AAChF,WAAO,KAAKtH,kBAAL,CAAwBuH,kBAAxB,CAA2C,gBAA3C,EAA6D5F,KAA7D,EAAoE2F,kBAApE,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI5I,EAAAA,QAAQ,CAAC4B,SAAT,CAAmBkH,6BAAnB,GAAmD,UAAU7F,KAAV,EAAiB2F,kBAAjB,EAAqC;AACpF,WAAO,KAAKtH,kBAAL,CAAwBuH,kBAAxB,CAA2C,cAA3C,EAA2D5F,KAA3D,EAAkE2F,kBAAlE,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","sourcesContent":["/*! firebase-admin v10.0.0 */\n\"use strict\";\n/*!\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseAuth = exports.createFirebaseTokenGenerator = void 0;\nvar error_1 = require(\"../utils/error\");\nvar deep_copy_1 = require(\"../utils/deep-copy\");\nvar validator = require(\"../utils/validator\");\nvar auth_api_request_1 = require(\"./auth-api-request\");\nvar token_generator_1 = require(\"./token-generator\");\nvar token_verifier_1 = require(\"./token-verifier\");\nvar auth_config_1 = require(\"./auth-config\");\nvar user_record_1 = require(\"./user-record\");\nvar identifier_1 = require(\"./identifier\");\nvar crypto_signer_1 = require(\"../utils/crypto-signer\");\n/**\n * @internal\n */\nfunction createFirebaseTokenGenerator(app, tenantId) {\n    try {\n        var signer = auth_api_request_1.useEmulator() ? new token_generator_1.EmulatedSigner() : crypto_signer_1.cryptoSignerFromApp(app);\n        return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);\n    }\n    catch (err) {\n        throw token_generator_1.handleCryptoSignerError(err);\n    }\n}\nexports.createFirebaseTokenGenerator = createFirebaseTokenGenerator;\n/**\n * Common parent interface for both `Auth` and `TenantAwareAuth` APIs.\n */\nvar BaseAuth = /** @class */ (function () {\n    /**\n     * The BaseAuth class constructor.\n     *\n     * @param app - The FirebaseApp to associate with this Auth instance.\n     * @param authRequestHandler - The RPC request handler for this instance.\n     * @param tokenGenerator - Optional token generator. If not specified, a\n     *     (non-tenant-aware) instance will be created. Use this paramter to\n     *     specify a tenant-aware tokenGenerator.\n     * @constructor\n     * @internal\n     */\n    function BaseAuth(app, \n    /** @internal */ authRequestHandler, tokenGenerator) {\n        this.authRequestHandler = authRequestHandler;\n        if (tokenGenerator) {\n            this.tokenGenerator = tokenGenerator;\n        }\n        else {\n            this.tokenGenerator = createFirebaseTokenGenerator(app);\n        }\n        this.sessionCookieVerifier = token_verifier_1.createSessionCookieVerifier(app);\n        this.idTokenVerifier = token_verifier_1.createIdTokenVerifier(app);\n    }\n    /**\n     * Creates a new Firebase custom token (JWT) that can be sent back to a client\n     * device to use to sign in with the client SDKs' `signInWithCustomToken()`\n     * methods. (Tenant-aware instances will also embed the tenant ID in the\n     * token.)\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/create-custom-tokens | Create Custom Tokens}\n     * for code samples and detailed documentation.\n     *\n     * @param uid - The `uid` to use as the custom token's subject.\n     * @param developerClaims - Optional additional claims to include\n     *   in the custom token's payload.\n     *\n     * @returns A promise fulfilled with a custom token for the\n     *   provided `uid` and payload.\n     */\n    BaseAuth.prototype.createCustomToken = function (uid, developerClaims) {\n        return this.tokenGenerator.createCustomToken(uid, developerClaims);\n    };\n    /**\n     * Verifies a Firebase ID token (JWT). If the token is valid, the promise is\n     * fulfilled with the token's decoded claims; otherwise, the promise is\n     * rejected.\n     *\n     * If `checkRevoked` is set to true, first verifies whether the corresponding\n     * user is disabled. If yes, an `auth/user-disabled` error is thrown. If no,\n     * verifies if the session corresponding to the ID token was revoked. If the\n     * corresponding user's session was invalidated, an `auth/id-token-revoked`\n     * error is thrown. If not specified the check is not applied.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/verify-id-tokens | Verify ID Tokens}\n     * for code samples and detailed documentation.\n     *\n     * @param idToken - The ID token to verify.\n     * @param checkRevoked - Whether to check if the ID token was revoked.\n     *   This requires an extra request to the Firebase Auth backend to check\n     *   the `tokensValidAfterTime` time for the corresponding user.\n     *   When not specified, this additional check is not applied.\n     *\n     * @returns A promise fulfilled with the\n     *   token's decoded claims if the ID token is valid; otherwise, a rejected\n     *   promise.\n     */\n    BaseAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n        var _this = this;\n        if (checkRevoked === void 0) { checkRevoked = false; }\n        var isEmulator = auth_api_request_1.useEmulator();\n        return this.idTokenVerifier.verifyJWT(idToken, isEmulator)\n            .then(function (decodedIdToken) {\n            // Whether to check if the token was revoked.\n            if (checkRevoked || isEmulator) {\n                return _this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n            }\n            return decodedIdToken;\n        });\n    };\n    /**\n     * Gets the user data for the user corresponding to a given `uid`.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n     * for code samples and detailed documentation.\n     *\n     * @param uid - The `uid` corresponding to the user whose data to fetch.\n     *\n     * @returns A promise fulfilled with the user\n     *   data corresponding to the provided `uid`.\n     */\n    BaseAuth.prototype.getUser = function (uid) {\n        return this.authRequestHandler.getAccountInfoByUid(uid)\n            .then(function (response) {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    };\n    /**\n     * Gets the user data for the user corresponding to a given email.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n     * for code samples and detailed documentation.\n     *\n     * @param email - The email corresponding to the user whose data to\n     *   fetch.\n     *\n     * @returns A promise fulfilled with the user\n     *   data corresponding to the provided email.\n     */\n    BaseAuth.prototype.getUserByEmail = function (email) {\n        return this.authRequestHandler.getAccountInfoByEmail(email)\n            .then(function (response) {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    };\n    /**\n     * Gets the user data for the user corresponding to a given phone number. The\n     * phone number has to conform to the E.164 specification.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n     * for code samples and detailed documentation.\n     *\n     * @param phoneNumber - The phone number corresponding to the user whose\n     *   data to fetch.\n     *\n     * @returns A promise fulfilled with the user\n     *   data corresponding to the provided phone number.\n     */\n    BaseAuth.prototype.getUserByPhoneNumber = function (phoneNumber) {\n        return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber)\n            .then(function (response) {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    };\n    /**\n     * Gets the user data for the user corresponding to a given provider id.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n     * for code samples and detailed documentation.\n     *\n     * @param providerId - The provider ID, for example, \"google.com\" for the\n     *   Google provider.\n     * @param uid - The user identifier for the given provider.\n     *\n     * @returns A promise fulfilled with the user data corresponding to the\n     *   given provider id.\n     */\n    BaseAuth.prototype.getUserByProviderUid = function (providerId, uid) {\n        // Although we don't really advertise it, we want to also handle\n        // non-federated idps with this call. So if we detect one of them, we'll\n        // reroute this request appropriately.\n        if (providerId === 'phone') {\n            return this.getUserByPhoneNumber(uid);\n        }\n        else if (providerId === 'email') {\n            return this.getUserByEmail(uid);\n        }\n        return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid)\n            .then(function (response) {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    };\n    /**\n     * Gets the user data corresponding to the specified identifiers.\n     *\n     * There are no ordering guarantees; in particular, the nth entry in the result list is not\n     * guaranteed to correspond to the nth entry in the input parameters list.\n     *\n     * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,\n     * this method throws a FirebaseAuthError.\n     *\n     * @param identifiers - The identifiers used to indicate which user records should be returned.\n     *     Must not have more than 100 entries.\n     * @returns A promise that resolves to the corresponding user records.\n     * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100\n     *     identifiers are specified.\n     */\n    BaseAuth.prototype.getUsers = function (identifiers) {\n        if (!validator.isArray(identifiers)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');\n        }\n        return this.authRequestHandler\n            .getAccountInfoByIdentifiers(identifiers)\n            .then(function (response) {\n            /**\n             * Checks if the specified identifier is within the list of\n             * UserRecords.\n             */\n            var isUserFound = (function (id, userRecords) {\n                return !!userRecords.find(function (userRecord) {\n                    if (identifier_1.isUidIdentifier(id)) {\n                        return id.uid === userRecord.uid;\n                    }\n                    else if (identifier_1.isEmailIdentifier(id)) {\n                        return id.email === userRecord.email;\n                    }\n                    else if (identifier_1.isPhoneIdentifier(id)) {\n                        return id.phoneNumber === userRecord.phoneNumber;\n                    }\n                    else if (identifier_1.isProviderIdentifier(id)) {\n                        var matchingUserInfo = userRecord.providerData.find(function (userInfo) {\n                            return id.providerId === userInfo.providerId;\n                        });\n                        return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;\n                    }\n                    else {\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');\n                    }\n                });\n            });\n            var users = response.users ? response.users.map(function (user) { return new user_record_1.UserRecord(user); }) : [];\n            var notFound = identifiers.filter(function (id) { return !isUserFound(id, users); });\n            return { users: users, notFound: notFound };\n        });\n    };\n    /**\n     * Retrieves a list of users (single batch only) with a size of `maxResults`\n     * starting from the offset as specified by `pageToken`. This is used to\n     * retrieve all the users of a specified project in batches.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#list_all_users | List all users}\n     * for code samples and detailed documentation.\n     *\n     * @param maxResults - The page size, 1000 if undefined. This is also\n     *   the maximum allowed limit.\n     * @param pageToken - The next page token. If not specified, returns\n     *   users starting without any offset.\n     * @returns A promise that resolves with\n     *   the current batch of downloaded users and the next page token.\n     */\n    BaseAuth.prototype.listUsers = function (maxResults, pageToken) {\n        return this.authRequestHandler.downloadAccount(maxResults, pageToken)\n            .then(function (response) {\n            // List of users to return.\n            var users = [];\n            // Convert each user response to a UserRecord.\n            response.users.forEach(function (userResponse) {\n                users.push(new user_record_1.UserRecord(userResponse));\n            });\n            // Return list of user records and the next page token if available.\n            var result = {\n                users: users,\n                pageToken: response.nextPageToken,\n            };\n            // Delete result.pageToken if undefined.\n            if (typeof result.pageToken === 'undefined') {\n                delete result.pageToken;\n            }\n            return result;\n        });\n    };\n    /**\n     * Creates a new user.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#create_a_user | Create a user}\n     * for code samples and detailed documentation.\n     *\n     * @param properties - The properties to set on the\n     *   new user record to be created.\n     *\n     * @returns A promise fulfilled with the user\n     *   data corresponding to the newly created user.\n     */\n    BaseAuth.prototype.createUser = function (properties) {\n        var _this = this;\n        return this.authRequestHandler.createNewAccount(properties)\n            .then(function (uid) {\n            // Return the corresponding user record.\n            return _this.getUser(uid);\n        })\n            .catch(function (error) {\n            if (error.code === 'auth/user-not-found') {\n                // Something must have happened after creating the user and then retrieving it.\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n            }\n            throw error;\n        });\n    };\n    /**\n     * Deletes an existing user.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#delete_a_user | Delete a user}\n     * for code samples and detailed documentation.\n     *\n     * @param uid - The `uid` corresponding to the user to delete.\n     *\n     * @returns An empty promise fulfilled once the user has been\n     *   deleted.\n     */\n    BaseAuth.prototype.deleteUser = function (uid) {\n        return this.authRequestHandler.deleteAccount(uid)\n            .then(function () {\n            // Return nothing on success.\n        });\n    };\n    /**\n     * Deletes the users specified by the given uids.\n     *\n     * Deleting a non-existing user won't generate an error (i.e. this method\n     * is idempotent.) Non-existing users are considered to be successfully\n     * deleted, and are therefore counted in the\n     * `DeleteUsersResult.successCount` value.\n     *\n     * Only a maximum of 1000 identifiers may be supplied. If more than 1000\n     * identifiers are supplied, this method throws a FirebaseAuthError.\n     *\n     * This API is currently rate limited at the server to 1 QPS. If you exceed\n     * this, you may get a quota exceeded error. Therefore, if you want to\n     * delete more than 1000 users, you may need to add a delay to ensure you\n     * don't go over this limit.\n     *\n     * @param uids - The `uids` corresponding to the users to delete.\n     *\n     * @returns A Promise that resolves to the total number of successful/failed\n     *     deletions, as well as the array of errors that corresponds to the\n     *     failed deletions.\n     */\n    BaseAuth.prototype.deleteUsers = function (uids) {\n        if (!validator.isArray(uids)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');\n        }\n        return this.authRequestHandler.deleteAccounts(uids, /*force=*/ true)\n            .then(function (batchDeleteAccountsResponse) {\n            var result = {\n                failureCount: 0,\n                successCount: uids.length,\n                errors: [],\n            };\n            if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {\n                return result;\n            }\n            result.failureCount = batchDeleteAccountsResponse.errors.length;\n            result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;\n            result.errors = batchDeleteAccountsResponse.errors.map(function (batchDeleteErrorInfo) {\n                if (batchDeleteErrorInfo.index === undefined) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');\n                }\n                var errMsgToError = function (msg) {\n                    // We unconditionally set force=true, so the 'NOT_DISABLED' error\n                    // should not be possible.\n                    var code = msg && msg.startsWith('NOT_DISABLED') ?\n                        error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;\n                    return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);\n                };\n                return {\n                    index: batchDeleteErrorInfo.index,\n                    error: errMsgToError(batchDeleteErrorInfo.message),\n                };\n            });\n            return result;\n        });\n    };\n    /**\n     * Updates an existing user.\n     *\n     * See {@link https://firebsae.google.com/docs/auth/admin/manage-users#update_a_user | Update a user}\n     * for code samples and detailed documentation.\n     *\n     * @param uid - The `uid` corresponding to the user to update.\n     * @param properties - The properties to update on\n     *   the provided user.\n     *\n     * @returns A promise fulfilled with the\n     *   updated user data.\n     */\n    BaseAuth.prototype.updateUser = function (uid, properties) {\n        var _this = this;\n        // Although we don't really advertise it, we want to also handle linking of\n        // non-federated idps with this call. So if we detect one of them, we'll\n        // adjust the properties parameter appropriately. This *does* imply that a\n        // conflict could arise, e.g. if the user provides a phoneNumber property,\n        // but also provides a providerToLink with a 'phone' provider id. In that\n        // case, we'll throw an error.\n        properties = deep_copy_1.deepCopy(properties);\n        if (properties === null || properties === void 0 ? void 0 : properties.providerToLink) {\n            if (properties.providerToLink.providerId === 'email') {\n                if (typeof properties.email !== 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To \"\n                        + 'link to the email/password provider, only specify the UpdateRequest.email field.');\n                }\n                properties.email = properties.providerToLink.uid;\n                delete properties.providerToLink;\n            }\n            else if (properties.providerToLink.providerId === 'phone') {\n                if (typeof properties.phoneNumber !== 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To \"\n                        + 'link to a phone provider, only specify the UpdateRequest.phoneNumber field.');\n                }\n                properties.phoneNumber = properties.providerToLink.uid;\n                delete properties.providerToLink;\n            }\n        }\n        if (properties === null || properties === void 0 ? void 0 : properties.providersToUnlink) {\n            if (properties.providersToUnlink.indexOf('phone') !== -1) {\n                // If we've been told to unlink the phone provider both via setting\n                // phoneNumber to null *and* by setting providersToUnlink to include\n                // 'phone', then we'll reject that. Though it might also be reasonable\n                // to relax this restriction and just unlink it.\n                if (properties.phoneNumber === null) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To \"\n                        + 'unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.');\n                }\n            }\n        }\n        return this.authRequestHandler.updateExistingAccount(uid, properties)\n            .then(function (existingUid) {\n            // Return the corresponding user record.\n            return _this.getUser(existingUid);\n        });\n    };\n    /**\n     * Sets additional developer claims on an existing user identified by the\n     * provided `uid`, typically used to define user roles and levels of\n     * access. These claims should propagate to all devices where the user is\n     * already signed in (after token expiration or when token refresh is forced)\n     * and the next time the user signs in. If a reserved OIDC claim name\n     * is used (sub, iat, iss, etc), an error is thrown. They are set on the\n     * authenticated user's ID token JWT.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/custom-claims |\n     * Defining user roles and access levels}\n     * for code samples and detailed documentation.\n     *\n     * @param uid - The `uid` of the user to edit.\n     * @param customUserClaims - The developer claims to set. If null is\n     *   passed, existing custom claims are deleted. Passing a custom claims payload\n     *   larger than 1000 bytes will throw an error. Custom claims are added to the\n     *   user's ID token which is transmitted on every authenticated request.\n     *   For profile non-access related user attributes, use database or other\n     *   separate storage systems.\n     * @returns A promise that resolves when the operation completes\n     *   successfully.\n     */\n    BaseAuth.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n        return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims)\n            .then(function () {\n            // Return nothing on success.\n        });\n    };\n    /**\n     * Revokes all refresh tokens for an existing user.\n     *\n     * This API will update the user's {@link UserRecord.tokensValidAfterTime} to\n     * the current UTC. It is important that the server on which this is called has\n     * its clock set correctly and synchronized.\n     *\n     * While this will revoke all sessions for a specified user and disable any\n     * new ID tokens for existing sessions from getting minted, existing ID tokens\n     * may remain active until their natural expiration (one hour). To verify that\n     * ID tokens are revoked, use {@link BaseAuth.verifyIdToken}\n     * where `checkRevoked` is set to true.\n     *\n     * @param uid - The `uid` corresponding to the user whose refresh tokens\n     *   are to be revoked.\n     *\n     * @returns An empty promise fulfilled once the user's refresh\n     *   tokens have been revoked.\n     */\n    BaseAuth.prototype.revokeRefreshTokens = function (uid) {\n        return this.authRequestHandler.revokeRefreshTokens(uid)\n            .then(function () {\n            // Return nothing on success.\n        });\n    };\n    /**\n     * Imports the provided list of users into Firebase Auth.\n     * A maximum of 1000 users are allowed to be imported one at a time.\n     * When importing users with passwords,\n     * {@link UserImportOptions} are required to be\n     * specified.\n     * This operation is optimized for bulk imports and will ignore checks on `uid`,\n     * `email` and other identifier uniqueness which could result in duplications.\n     *\n     * @param users - The list of user records to import to Firebase Auth.\n     * @param options - The user import options, required when the users provided include\n     *   password credentials.\n     * @returns A promise that resolves when\n     *   the operation completes with the result of the import. This includes the\n     *   number of successful imports, the number of failed imports and their\n     *   corresponding errors.\n    */\n    BaseAuth.prototype.importUsers = function (users, options) {\n        return this.authRequestHandler.uploadAccount(users, options);\n    };\n    /**\n     * Creates a new Firebase session cookie with the specified options. The created\n     * JWT string can be set as a server-side session cookie with a custom cookie\n     * policy, and be used for session management. The session cookie JWT will have\n     * the same payload claims as the provided ID token.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies | Manage Session Cookies}\n     * for code samples and detailed documentation.\n     *\n     * @param idToken - The Firebase ID token to exchange for a session\n     *   cookie.\n     * @param sessionCookieOptions - The session\n     *   cookie options which includes custom session duration.\n     *\n     * @returns A promise that resolves on success with the\n     *   created session cookie.\n     */\n    BaseAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n        // Return rejected promise if expiresIn is not available.\n        if (!validator.isNonNullObject(sessionCookieOptions) ||\n            !validator.isNumber(sessionCookieOptions.expiresIn)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n        }\n        return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n    };\n    /**\n     * Verifies a Firebase session cookie. Returns a Promise with the cookie claims.\n     * Rejects the promise if the cookie could not be verified.\n     *\n     * If `checkRevoked` is set to true, first verifies whether the corresponding\n     * user is disabled: If yes, an `auth/user-disabled` error is thrown. If no,\n     * verifies if the session corresponding to the session cookie was revoked.\n     * If the corresponding user's session was invalidated, an\n     * `auth/session-cookie-revoked` error is thrown. If not specified the check\n     * is not performed.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies#verify_session_cookie_and_check_permissions |\n     * Verify Session Cookies}\n     * for code samples and detailed documentation\n     *\n     * @param sessionCookie - The session cookie to verify.\n     * @param checkForRevocation -  Whether to check if the session cookie was\n     *   revoked. This requires an extra request to the Firebase Auth backend to\n     *   check the `tokensValidAfterTime` time for the corresponding user.\n     *   When not specified, this additional check is not performed.\n     *\n     * @returns A promise fulfilled with the\n     *   session cookie's decoded claims if the session cookie is valid; otherwise,\n     *   a rejected promise.\n     */\n    BaseAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n        var _this = this;\n        if (checkRevoked === void 0) { checkRevoked = false; }\n        var isEmulator = auth_api_request_1.useEmulator();\n        return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator)\n            .then(function (decodedIdToken) {\n            // Whether to check if the token was revoked.\n            if (checkRevoked || isEmulator) {\n                return _this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n            }\n            return decodedIdToken;\n        });\n    };\n    /**\n     * Generates the out of band email action link to reset a user's password.\n     * The link is generated for the user with the specified email address. The\n     * optional  {@link ActionCodeSettings} object\n     * defines whether the link is to be handled by a mobile app or browser and the\n     * additional state information to be passed in the deep link, etc.\n     *\n     * @example\n     * ```javascript\n     * var actionCodeSettings = {\n     *   url: 'https://www.example.com/?email=user@example.com',\n     *   iOS: {\n     *     bundleId: 'com.example.ios'\n     *   },\n     *   android: {\n     *     packageName: 'com.example.android',\n     *     installApp: true,\n     *     minimumVersion: '12'\n     *   },\n     *   handleCodeInApp: true,\n     *   dynamicLinkDomain: 'custom.page.link'\n     * };\n     * admin.auth()\n     *     .generatePasswordResetLink('user@example.com', actionCodeSettings)\n     *     .then(function(link) {\n     *       // The link was successfully generated.\n     *     })\n     *     .catch(function(error) {\n     *       // Some error occurred, you can inspect the code: error.code\n     *     });\n     * ```\n     *\n     * @param email - The email address of the user whose password is to be\n     *   reset.\n     * @param actionCodeSettings - The action\n     *     code settings. If specified, the state/continue URL is set as the\n     *     \"continueUrl\" parameter in the password reset link. The default password\n     *     reset landing page will use this to display a link to go back to the app\n     *     if it is installed.\n     *     If the actionCodeSettings is not specified, no URL is appended to the\n     *     action URL.\n     *     The state URL provided must belong to a domain that is whitelisted by the\n     *     developer in the console. Otherwise an error is thrown.\n     *     Mobile app redirects are only applicable if the developer configures\n     *     and accepts the Firebase Dynamic Links terms of service.\n     *     The Android package name and iOS bundle ID are respected only if they\n     *     are configured in the same Firebase Auth project.\n     * @returns A promise that resolves with the generated link.\n     */\n    BaseAuth.prototype.generatePasswordResetLink = function (email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n    };\n    /**\n     * Generates the out of band email action link to verify the user's ownership\n     * of the specified email. The {@link ActionCodeSettings} object provided\n     * as an argument to this method defines whether the link is to be handled by a\n     * mobile app or browser along with additional state information to be passed in\n     * the deep link, etc.\n     *\n     * @example\n     * ```javascript\n     * var actionCodeSettings = {\n     *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\n     *   iOS: {\n     *     bundleId: 'com.example.ios'\n     *   },\n     *   android: {\n     *     packageName: 'com.example.android',\n     *     installApp: true,\n     *     minimumVersion: '12'\n     *   },\n     *   handleCodeInApp: true,\n     *   dynamicLinkDomain: 'custom.page.link'\n     * };\n     * admin.auth()\n     *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\n     *     .then(function(link) {\n     *       // The link was successfully generated.\n     *     })\n     *     .catch(function(error) {\n     *       // Some error occurred, you can inspect the code: error.code\n     *     });\n     * ```\n     *\n     * @param email - The email account to verify.\n     * @param actionCodeSettings - The action\n     *     code settings. If specified, the state/continue URL is set as the\n     *     \"continueUrl\" parameter in the email verification link. The default email\n     *     verification landing page will use this to display a link to go back to\n     *     the app if it is installed.\n     *     If the actionCodeSettings is not specified, no URL is appended to the\n     *     action URL.\n     *     The state URL provided must belong to a domain that is whitelisted by the\n     *     developer in the console. Otherwise an error is thrown.\n     *     Mobile app redirects are only applicable if the developer configures\n     *     and accepts the Firebase Dynamic Links terms of service.\n     *     The Android package name and iOS bundle ID are respected only if they\n     *     are configured in the same Firebase Auth project.\n     * @returns A promise that resolves with the generated link.\n     */\n    BaseAuth.prototype.generateEmailVerificationLink = function (email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n    };\n    /**\n     * Generates the out of band email action link to verify the user's ownership\n     * of the specified email. The {@link ActionCodeSettings} object provided\n     * as an argument to this method defines whether the link is to be handled by a\n     * mobile app or browser along with additional state information to be passed in\n     * the deep link, etc.\n     *\n     * @example\n     * ```javascript\n     * var actionCodeSettings = {\n     *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\n     *   iOS: {\n     *     bundleId: 'com.example.ios'\n     *   },\n     *   android: {\n     *     packageName: 'com.example.android',\n     *     installApp: true,\n     *     minimumVersion: '12'\n     *   },\n     *   handleCodeInApp: true,\n     *   dynamicLinkDomain: 'custom.page.link'\n     * };\n     * admin.auth()\n     *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\n     *     .then(function(link) {\n     *       // The link was successfully generated.\n     *     })\n     *     .catch(function(error) {\n     *       // Some error occurred, you can inspect the code: error.code\n     *     });\n     * ```\n     *\n     * @param email - The email account to verify.\n     * @param actionCodeSettings - The action\n     *     code settings. If specified, the state/continue URL is set as the\n     *     \"continueUrl\" parameter in the email verification link. The default email\n     *     verification landing page will use this to display a link to go back to\n     *     the app if it is installed.\n     *     If the actionCodeSettings is not specified, no URL is appended to the\n     *     action URL.\n     *     The state URL provided must belong to a domain that is whitelisted by the\n     *     developer in the console. Otherwise an error is thrown.\n     *     Mobile app redirects are only applicable if the developer configures\n     *     and accepts the Firebase Dynamic Links terms of service.\n     *     The Android package name and iOS bundle ID are respected only if they\n     *     are configured in the same Firebase Auth project.\n     * @returns A promise that resolves with the generated link.\n     */\n    BaseAuth.prototype.generateSignInWithEmailLink = function (email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n    };\n    /**\n     * Returns the list of existing provider configurations matching the filter\n     * provided. At most, 100 provider configs can be listed at a time.\n     *\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\n     * (GCIP). To learn more about GCIP, including pricing and features,\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n     *\n     * @param options - The provider config filter to apply.\n     * @returns A promise that resolves with the list of provider configs meeting the\n     *   filter requirements.\n     */\n    BaseAuth.prototype.listProviderConfigs = function (options) {\n        var processResponse = function (response, providerConfigs) {\n            // Return list of provider configuration and the next page token if available.\n            var result = {\n                providerConfigs: providerConfigs,\n            };\n            // Delete result.pageToken if undefined.\n            if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {\n                result.pageToken = response.nextPageToken;\n            }\n            return result;\n        };\n        if (options && options.type === 'oidc') {\n            return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken)\n                .then(function (response) {\n                // List of provider configurations to return.\n                var providerConfigs = [];\n                // Convert each provider config response to a OIDCConfig.\n                response.oauthIdpConfigs.forEach(function (configResponse) {\n                    providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\n                });\n                // Return list of provider configuration and the next page token if available.\n                return processResponse(response, providerConfigs);\n            });\n        }\n        else if (options && options.type === 'saml') {\n            return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken)\n                .then(function (response) {\n                // List of provider configurations to return.\n                var providerConfigs = [];\n                // Convert each provider config response to a SAMLConfig.\n                response.inboundSamlConfigs.forEach(function (configResponse) {\n                    providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\n                });\n                // Return list of provider configuration and the next page token if available.\n                return processResponse(response, providerConfigs);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"AuthProviderConfigFilter.type\" must be either \"saml\" or \"oidc\"'));\n    };\n    /**\n     * Looks up an Auth provider configuration by the provided ID.\n     * Returns a promise that resolves with the provider configuration\n     * corresponding to the provider ID specified. If the specified ID does not\n     * exist, an `auth/configuration-not-found` error is thrown.\n     *\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\n     * (GCIP). To learn more about GCIP, including pricing and features,\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n     *\n     * @param providerId - The provider ID corresponding to the provider\n     *     config to return.\n     * @returns A promise that resolves\n     *     with the configuration corresponding to the provided ID.\n     */\n    BaseAuth.prototype.getProviderConfig = function (providerId) {\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.getOAuthIdpConfig(providerId)\n                .then(function (response) {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.getInboundSamlConfig(providerId)\n                .then(function (response) {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Deletes the provider configuration corresponding to the provider ID passed.\n     * If the specified ID does not exist, an `auth/configuration-not-found` error\n     * is thrown.\n     *\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\n     * (GCIP). To learn more about GCIP, including pricing and features,\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n     *\n     * @param providerId - The provider ID corresponding to the provider\n     *     config to delete.\n     * @returns A promise that resolves on completion.\n     */\n    BaseAuth.prototype.deleteProviderConfig = function (providerId) {\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.deleteInboundSamlConfig(providerId);\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Returns a promise that resolves with the updated `AuthProviderConfig`\n     * corresponding to the provider ID specified.\n     * If the specified ID does not exist, an `auth/configuration-not-found` error\n     * is thrown.\n     *\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\n     * (GCIP). To learn more about GCIP, including pricing and features,\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n     *\n     * @param providerId - The provider ID corresponding to the provider\n     *     config to update.\n     * @param updatedConfig - The updated configuration.\n     * @returns A promise that resolves with the updated provider configuration.\n     */\n    BaseAuth.prototype.updateProviderConfig = function (providerId, updatedConfig) {\n        if (!validator.isNonNullObject(updatedConfig)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\n        }\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig)\n                .then(function (response) {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig)\n                .then(function (response) {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Returns a promise that resolves with the newly created `AuthProviderConfig`\n     * when the new provider configuration is created.\n     *\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\n     * (GCIP). To learn more about GCIP, including pricing and features,\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n     *\n     * @param config - The provider configuration to create.\n     * @returns A promise that resolves with the created provider configuration.\n     */\n    BaseAuth.prototype.createProviderConfig = function (config) {\n        if (!validator.isNonNullObject(config)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\n        }\n        if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\n            return this.authRequestHandler.createOAuthIdpConfig(config)\n                .then(function (response) {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\n            return this.authRequestHandler.createInboundSamlConfig(config)\n                .then(function (response) {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Verifies the decoded Firebase issued JWT is not revoked or disabled. Returns a promise that\n     * resolves with the decoded claims on success. Rejects the promise with revocation error if revoked\n     * or user disabled.\n     *\n     * @param decodedIdToken - The JWT's decoded claims.\n     * @param revocationErrorInfo - The revocation error info to throw on revocation\n     *     detection.\n     * @returns A promise that will be fulfilled after a successful verification.\n     */\n    BaseAuth.prototype.verifyDecodedJWTNotRevokedOrDisabled = function (decodedIdToken, revocationErrorInfo) {\n        // Get tokens valid after time for the corresponding user.\n        return this.getUser(decodedIdToken.sub)\n            .then(function (user) {\n            if (user.disabled) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_DISABLED, 'The user record is disabled.');\n            }\n            // If no tokens valid after time available, token is not revoked.\n            if (user.tokensValidAfterTime) {\n                // Get the ID token authentication time and convert to milliseconds UTC.\n                var authTimeUtc = decodedIdToken.auth_time * 1000;\n                // Get user tokens valid after time in milliseconds UTC.\n                var validSinceUtc = new Date(user.tokensValidAfterTime).getTime();\n                // Check if authentication time is older than valid since time.\n                if (authTimeUtc < validSinceUtc) {\n                    throw new error_1.FirebaseAuthError(revocationErrorInfo);\n                }\n            }\n            // All checks above passed. Return the decoded token.\n            return decodedIdToken;\n        });\n    };\n    return BaseAuth;\n}());\nexports.BaseAuth = BaseAuth;\n"]},"metadata":{},"sourceType":"script"}